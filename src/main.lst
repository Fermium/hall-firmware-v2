   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.portwrite,"ax",@progbits
  11               	.global	portwrite
  13               	portwrite:
  14               	.LFB6:
  15               		.file 1 "./src/pins.h"
   1:./src/pins.h  **** //example usage
   2:./src/pins.h  **** // portwrite (0x0A, 2, true)  //write high on PORTA2
   3:./src/pins.h  **** // portwrite (0x0B, 3, false) //write low on PORTB3
   4:./src/pins.h  **** #include <stdbool.h>
   5:./src/pins.h  **** #include <avr/io.h>
   6:./src/pins.h  **** 
   7:./src/pins.h  **** 
   8:./src/pins.h  **** void portwrite (char port, char pincacca, bool outvalue)
   9:./src/pins.h  **** {
  16               		.loc 1 9 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  10:./src/pins.h  ****   unsigned char set_pin = 1 << pincacca;
  23               		.loc 1 10 0
  24 0000 21E0      		ldi r18,lo8(1)
  25 0002 30E0      		ldi r19,0
  26 0004 00C0      		rjmp 2f
  27               		1:
  28 0006 220F      		lsl r18
  29               		2:
  30 0008 6A95      		dec r22
  31 000a 02F4      		brpl 1b
  32               	.LVL1:
  11:./src/pins.h  ****   unsigned char clear_pin = ~set_pin;
  33               		.loc 1 11 0
  34 000c 922F      		mov r25,r18
  35 000e 9095      		com r25
  36               	.LVL2:
  12:./src/pins.h  ****   
  13:./src/pins.h  ****   switch (port) {
  37               		.loc 1 13 0
  38 0010 8C30      		cpi r24,lo8(12)
  39 0012 01F0      		breq .L3
  40 0014 00F4      		brsh .L4
  41 0016 8B30      		cpi r24,lo8(11)
  42 0018 01F0      		breq .L5
  43 001a 0895      		ret
  44               	.L4:
  45 001c 8D30      		cpi r24,lo8(13)
  46 001e 01F0      		breq .L6
  47 0020 8E30      		cpi r24,lo8(14)
  48 0022 01F0      		breq .L7
  49 0024 0895      		ret
  50               	.L5:
  14:./src/pins.h  ****     case 0x0B:  
  15:./src/pins.h  ****       outvalue  ? (PORTB |= set_pin) : (PORTB &= clear_pin);
  51               		.loc 1 15 0
  52 0026 85B1      		in r24,0x5
  53               	.LVL3:
  54 0028 4423      		tst r20
  55 002a 01F0      		breq .L8
  56               		.loc 1 15 0 is_stmt 0 discriminator 1
  57 002c 282B      		or r18,r24
  58               	.LVL4:
  59 002e 25B9      		out 0x5,r18
  60 0030 0895      		ret
  61               	.LVL5:
  62               	.L8:
  63               		.loc 1 15 0 discriminator 2
  64 0032 9823      		and r25,r24
  65               	.LVL6:
  66 0034 95B9      		out 0x5,r25
  67 0036 0895      		ret
  68               	.LVL7:
  69               	.L3:
  16:./src/pins.h  ****       break;
  17:./src/pins.h  ****     case 0x0C:
  18:./src/pins.h  ****       outvalue  ? (PORTC |= set_pin) : (PORTC &= clear_pin);
  70               		.loc 1 18 0 is_stmt 1
  71 0038 88B1      		in r24,0x8
  72               	.LVL8:
  73 003a 4111      		cpse r20,__zero_reg__
  74 003c 00C0      		rjmp .L12
  75               		.loc 1 18 0 is_stmt 0 discriminator 2
  76 003e 9823      		and r25,r24
  77               	.LVL9:
  78 0040 98B9      		out 0x8,r25
  79 0042 0895      		ret
  80               	.LVL10:
  81               	.L6:
  19:./src/pins.h  ****       break;
  20:./src/pins.h  ****     case 0x0D:
  21:./src/pins.h  ****       outvalue  ? (PORTC |= set_pin) : (PORTD &= clear_pin);
  82               		.loc 1 21 0 is_stmt 1
  83 0044 4423      		tst r20
  84 0046 01F0      		breq .L10
  85               		.loc 1 21 0 is_stmt 0 discriminator 1
  86 0048 88B1      		in r24,0x8
  87               	.LVL11:
  88               	.L12:
  89 004a 282B      		or r18,r24
  90               	.LVL12:
  91 004c 28B9      		out 0x8,r18
  92 004e 0895      		ret
  93               	.LVL13:
  94               	.L10:
  95               		.loc 1 21 0 discriminator 2
  96 0050 8BB1      		in r24,0xb
  97               	.LVL14:
  98 0052 9823      		and r25,r24
  99               	.LVL15:
 100 0054 9BB9      		out 0xb,r25
 101 0056 0895      		ret
 102               	.LVL16:
 103               	.L7:
  22:./src/pins.h  ****       break;
  23:./src/pins.h  ****     case 0x0E:
  24:./src/pins.h  ****       outvalue  ? (PORTE |= set_pin) : (PORTE &= clear_pin);
 104               		.loc 1 24 0 is_stmt 1
 105 0058 8EB1      		in r24,0xe
 106               	.LVL17:
 107 005a 4423      		tst r20
 108 005c 01F0      		breq .L11
 109               		.loc 1 24 0 is_stmt 0 discriminator 1
 110 005e 282B      		or r18,r24
 111               	.LVL18:
 112 0060 2EB9      		out 0xe,r18
 113 0062 0895      		ret
 114               	.LVL19:
 115               	.L11:
 116               		.loc 1 24 0 discriminator 2
 117 0064 9823      		and r25,r24
 118               	.LVL20:
 119 0066 9EB9      		out 0xe,r25
 120 0068 0895      		ret
 121               		.cfi_endproc
 122               	.LFE6:
 124               		.section	.text.i2c_init,"ax",@progbits
 125               	.global	i2c_init
 127               	i2c_init:
 128               	.LFB7:
 129               		.file 2 "./src/i2c.h"
   1:./src/i2c.h   **** #ifndef  F_CPU
   2:./src/i2c.h   **** #define F_CPU 16000000UL
   3:./src/i2c.h   **** #endif
   4:./src/i2c.h   **** 
   5:./src/i2c.h   **** 
   6:./src/i2c.h   **** #define I2C_READ 0x01
   7:./src/i2c.h   **** #define I2C_WRITE 0x00
   8:./src/i2c.h   **** 
   9:./src/i2c.h   **** #include <avr/io.h>
  10:./src/i2c.h   **** #include <util/twi.h>
  11:./src/i2c.h   **** 
  12:./src/i2c.h   **** 
  13:./src/i2c.h   **** #define F_SCL 100000UL // SCL frequency
  14:./src/i2c.h   **** #define Prescaler 1
  15:./src/i2c.h   **** #define TWBR_val ((((F_CPU / F_SCL) / Prescaler) - 16 ) / 2)
  16:./src/i2c.h   **** 
  17:./src/i2c.h   **** void i2c_init(void)
  18:./src/i2c.h   **** {
 130               		.loc 2 18 0 is_stmt 1
 131               		.cfi_startproc
 132               	/* prologue: function */
 133               	/* frame size = 0 */
 134               	/* stack size = 0 */
 135               	.L__stack_usage = 0
  19:./src/i2c.h   **** 	TWBR = (uint8_t)TWBR_val;
 136               		.loc 2 19 0
 137 0000 88E4      		ldi r24,lo8(72)
 138 0002 8093 B800 		sts 184,r24
 139 0006 0895      		ret
 140               		.cfi_endproc
 141               	.LFE7:
 143               		.section	.text.i2c_start,"ax",@progbits
 144               	.global	i2c_start
 146               	i2c_start:
 147               	.LFB8:
  20:./src/i2c.h   **** }
  21:./src/i2c.h   **** 
  22:./src/i2c.h   **** uint8_t i2c_start(uint8_t address)
  23:./src/i2c.h   **** {
 148               		.loc 2 23 0
 149               		.cfi_startproc
 150               	.LVL21:
 151               	/* prologue: function */
 152               	/* frame size = 0 */
 153               	/* stack size = 0 */
 154               	.L__stack_usage = 0
  24:./src/i2c.h   **** 	// reset TWI control register
  25:./src/i2c.h   **** 	TWCR = 0;
 155               		.loc 2 25 0
 156 0000 1092 BC00 		sts 188,__zero_reg__
  26:./src/i2c.h   **** 	// transmit START condition 
  27:./src/i2c.h   **** 	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
 157               		.loc 2 27 0
 158 0004 94EA      		ldi r25,lo8(-92)
 159 0006 9093 BC00 		sts 188,r25
 160               	.L16:
  28:./src/i2c.h   **** 	// wait for end of transmission
  29:./src/i2c.h   **** 	while( !(TWCR & (1<<TWINT)) );
 161               		.loc 2 29 0 discriminator 1
 162 000a 9091 BC00 		lds r25,188
 163 000e 97FF      		sbrs r25,7
 164 0010 00C0      		rjmp .L16
  30:./src/i2c.h   **** 	
  31:./src/i2c.h   **** 	// check if the start condition was successfully transmitted
  32:./src/i2c.h   **** 	if((TWSR & 0xF8) != TW_START){ return 1; }
 165               		.loc 2 32 0
 166 0012 9091 B900 		lds r25,185
 167 0016 987F      		andi r25,lo8(-8)
 168 0018 9830      		cpi r25,lo8(8)
 169 001a 01F0      		breq .L17
 170               	.LVL22:
 171               	.L20:
 172 001c 81E0      		ldi r24,lo8(1)
 173 001e 0895      		ret
 174               	.LVL23:
 175               	.L17:
 176               	.LBB20:
 177               	.LBB21:
  33:./src/i2c.h   **** 	
  34:./src/i2c.h   **** 	// load slave address into data register
  35:./src/i2c.h   **** 	TWDR = address;
 178               		.loc 2 35 0
 179 0020 8093 BB00 		sts 187,r24
  36:./src/i2c.h   **** 	// start transmission of address
  37:./src/i2c.h   **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 180               		.loc 2 37 0
 181 0024 84E8      		ldi r24,lo8(-124)
 182               	.LVL24:
 183 0026 8093 BC00 		sts 188,r24
 184               	.LVL25:
 185               	.L19:
  38:./src/i2c.h   **** 	// wait for end of transmission
  39:./src/i2c.h   **** 	while( !(TWCR & (1<<TWINT)) );
 186               		.loc 2 39 0
 187 002a 8091 BC00 		lds r24,188
 188 002e 87FF      		sbrs r24,7
 189 0030 00C0      		rjmp .L19
  40:./src/i2c.h   **** 	
  41:./src/i2c.h   **** 	// check if the device has acknowledged the READ / WRITE mode
  42:./src/i2c.h   **** 	uint8_t twst = TW_STATUS & 0xF8;
 190               		.loc 2 42 0
 191 0032 8091 B900 		lds r24,185
 192 0036 887F      		andi r24,lo8(-8)
 193               	.LVL26:
  43:./src/i2c.h   **** 	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
 194               		.loc 2 43 0
 195 0038 8831      		cpi r24,lo8(24)
 196 003a 01F0      		breq .L21
 197 003c 8034      		cpi r24,lo8(64)
 198 003e 01F4      		brne .L20
 199               	.L21:
  44:./src/i2c.h   **** 	
  45:./src/i2c.h   **** 	return 0;
 200               		.loc 2 45 0
 201 0040 80E0      		ldi r24,0
 202               	.LVL27:
 203               	.LBE21:
 204               	.LBE20:
  46:./src/i2c.h   **** }
 205               		.loc 2 46 0
 206 0042 0895      		ret
 207               		.cfi_endproc
 208               	.LFE8:
 210               		.section	.text.i2c_write,"ax",@progbits
 211               	.global	i2c_write
 213               	i2c_write:
 214               	.LFB9:
  47:./src/i2c.h   **** 
  48:./src/i2c.h   **** uint8_t i2c_write(uint8_t data)
  49:./src/i2c.h   **** {
 215               		.loc 2 49 0
 216               		.cfi_startproc
 217               	.LVL28:
 218               	/* prologue: function */
 219               	/* frame size = 0 */
 220               	/* stack size = 0 */
 221               	.L__stack_usage = 0
  50:./src/i2c.h   **** 	// load data into data register
  51:./src/i2c.h   **** 	TWDR = data;
 222               		.loc 2 51 0
 223 0000 8093 BB00 		sts 187,r24
  52:./src/i2c.h   **** 	// start transmission of data
  53:./src/i2c.h   **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 224               		.loc 2 53 0
 225 0004 84E8      		ldi r24,lo8(-124)
 226               	.LVL29:
 227 0006 8093 BC00 		sts 188,r24
 228               	.LVL30:
 229               	.L25:
  54:./src/i2c.h   **** 	// wait for end of transmission
  55:./src/i2c.h   **** 	while( !(TWCR & (1<<TWINT)) );
 230               		.loc 2 55 0 discriminator 1
 231 000a 8091 BC00 		lds r24,188
 232 000e 87FF      		sbrs r24,7
 233 0010 00C0      		rjmp .L25
  56:./src/i2c.h   **** 	
  57:./src/i2c.h   **** 	if( (TWSR & 0xF8) != TW_MT_DATA_ACK ){ return 1; }
 234               		.loc 2 57 0
 235 0012 9091 B900 		lds r25,185
 236 0016 987F      		andi r25,lo8(-8)
 237 0018 81E0      		ldi r24,lo8(1)
 238 001a 9832      		cpi r25,lo8(40)
 239 001c 01F4      		brne .L26
 240 001e 80E0      		ldi r24,0
 241               	.L26:
  58:./src/i2c.h   **** 	
  59:./src/i2c.h   **** 	return 0;
  60:./src/i2c.h   **** }
 242               		.loc 2 60 0
 243 0020 0895      		ret
 244               		.cfi_endproc
 245               	.LFE9:
 247               		.section	.text.i2c_read_ack,"ax",@progbits
 248               	.global	i2c_read_ack
 250               	i2c_read_ack:
 251               	.LFB10:
  61:./src/i2c.h   **** 
  62:./src/i2c.h   **** uint8_t i2c_read_ack(void)
  63:./src/i2c.h   **** {
 252               		.loc 2 63 0
 253               		.cfi_startproc
 254               	/* prologue: function */
 255               	/* frame size = 0 */
 256               	/* stack size = 0 */
 257               	.L__stack_usage = 0
  64:./src/i2c.h   **** 	
  65:./src/i2c.h   **** 	// start TWI module and acknowledge data after reception
  66:./src/i2c.h   **** 	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA); 
 258               		.loc 2 66 0
 259 0000 84EC      		ldi r24,lo8(-60)
 260 0002 8093 BC00 		sts 188,r24
 261               	.L29:
  67:./src/i2c.h   **** 	// wait for end of transmission
  68:./src/i2c.h   **** 	while( !(TWCR & (1<<TWINT)) );
 262               		.loc 2 68 0 discriminator 1
 263 0006 8091 BC00 		lds r24,188
 264 000a 87FF      		sbrs r24,7
 265 000c 00C0      		rjmp .L29
  69:./src/i2c.h   **** 	// return received data from TWDR
  70:./src/i2c.h   **** 	return TWDR;
 266               		.loc 2 70 0
 267 000e 8091 BB00 		lds r24,187
  71:./src/i2c.h   **** }
 268               		.loc 2 71 0
 269 0012 0895      		ret
 270               		.cfi_endproc
 271               	.LFE10:
 273               		.section	.text.i2c_read_nack,"ax",@progbits
 274               	.global	i2c_read_nack
 276               	i2c_read_nack:
 277               	.LFB11:
  72:./src/i2c.h   **** 
  73:./src/i2c.h   **** uint8_t i2c_read_nack(void)
  74:./src/i2c.h   **** {
 278               		.loc 2 74 0
 279               		.cfi_startproc
 280               	/* prologue: function */
 281               	/* frame size = 0 */
 282               	/* stack size = 0 */
 283               	.L__stack_usage = 0
  75:./src/i2c.h   **** 	
  76:./src/i2c.h   **** 	// start receiving without acknowledging reception
  77:./src/i2c.h   **** 	TWCR = (1<<TWINT) | (1<<TWEN);
 284               		.loc 2 77 0
 285 0000 84E8      		ldi r24,lo8(-124)
 286 0002 8093 BC00 		sts 188,r24
 287               	.L32:
  78:./src/i2c.h   **** 	// wait for end of transmission
  79:./src/i2c.h   **** 	while( !(TWCR & (1<<TWINT)) );
 288               		.loc 2 79 0 discriminator 1
 289 0006 8091 BC00 		lds r24,188
 290 000a 87FF      		sbrs r24,7
 291 000c 00C0      		rjmp .L32
  80:./src/i2c.h   **** 	// return received data from TWDR
  81:./src/i2c.h   **** 	return TWDR;
 292               		.loc 2 81 0
 293 000e 8091 BB00 		lds r24,187
  82:./src/i2c.h   **** }
 294               		.loc 2 82 0
 295 0012 0895      		ret
 296               		.cfi_endproc
 297               	.LFE11:
 299               		.section	.text.i2c_transmit,"ax",@progbits
 300               	.global	i2c_transmit
 302               	i2c_transmit:
 303               	.LFB12:
  83:./src/i2c.h   **** 
  84:./src/i2c.h   **** uint8_t i2c_transmit(uint8_t address, uint8_t* data, uint16_t length)
  85:./src/i2c.h   **** {
 304               		.loc 2 85 0
 305               		.cfi_startproc
 306               	.LVL31:
 307 0000 CF92      		push r12
 308               	.LCFI0:
 309               		.cfi_def_cfa_offset 3
 310               		.cfi_offset 12, -2
 311 0002 DF92      		push r13
 312               	.LCFI1:
 313               		.cfi_def_cfa_offset 4
 314               		.cfi_offset 13, -3
 315 0004 EF92      		push r14
 316               	.LCFI2:
 317               		.cfi_def_cfa_offset 5
 318               		.cfi_offset 14, -4
 319 0006 FF92      		push r15
 320               	.LCFI3:
 321               		.cfi_def_cfa_offset 6
 322               		.cfi_offset 15, -5
 323 0008 1F93      		push r17
 324               	.LCFI4:
 325               		.cfi_def_cfa_offset 7
 326               		.cfi_offset 17, -6
 327 000a CF93      		push r28
 328               	.LCFI5:
 329               		.cfi_def_cfa_offset 8
 330               		.cfi_offset 28, -7
 331 000c DF93      		push r29
 332               	.LCFI6:
 333               		.cfi_def_cfa_offset 9
 334               		.cfi_offset 29, -8
 335 000e 00D0      		rcall .
 336               	.LCFI7:
 337               		.cfi_def_cfa_offset 11
 338 0010 CDB7      		in r28,__SP_L__
 339 0012 DEB7      		in r29,__SP_H__
 340               	.LCFI8:
 341               		.cfi_def_cfa_register 28
 342               	/* prologue: function */
 343               	/* frame size = 2 */
 344               	/* stack size = 9 */
 345               	.L__stack_usage = 9
 346 0014 7A01      		movw r14,r20
  86:./src/i2c.h   **** 	if (i2c_start(address | I2C_WRITE)) return 1;
 347               		.loc 2 86 0
 348 0016 6983      		std Y+1,r22
 349 0018 7A83      		std Y+2,r23
 350 001a 0E94 0000 		call i2c_start
 351               	.LVL32:
 352 001e 182F      		mov r17,r24
 353 0020 6981      		ldd r22,Y+1
 354 0022 7A81      		ldd r23,Y+2
 355 0024 8111      		cpse r24,__zero_reg__
 356 0026 00C0      		rjmp .L35
 357 0028 6B01      		movw r12,r22
 358 002a EC0C      		add r14,r12
 359 002c FD1C      		adc r15,r13
 360               	.LVL33:
 361               	.L36:
 362               	.LBB22:
  87:./src/i2c.h   **** 	
  88:./src/i2c.h   **** 	for (uint16_t i = 0; i < length; i++)
 363               		.loc 2 88 0 discriminator 1
 364 002e CE14      		cp r12,r14
 365 0030 DF04      		cpc r13,r15
 366 0032 01F0      		breq .L39
  89:./src/i2c.h   **** 	{
  90:./src/i2c.h   **** 		if (i2c_write(data[i])) return 1;
 367               		.loc 2 90 0
 368 0034 F601      		movw r30,r12
 369 0036 8191      		ld r24,Z+
 370 0038 6F01      		movw r12,r30
 371               	.LVL34:
 372 003a 0E94 0000 		call i2c_write
 373               	.LVL35:
 374 003e 8823      		tst r24
 375 0040 01F0      		breq .L36
 376               	.LVL36:
 377               	.L35:
 378               	.LBE22:
  86:./src/i2c.h   **** 	
 379               		.loc 2 86 0
 380 0042 11E0      		ldi r17,lo8(1)
 381 0044 00C0      		rjmp .L37
 382               	.LVL37:
 383               	.L39:
 384               	.LBB23:
 385               	.LBB24:
  91:./src/i2c.h   **** 	}
  92:./src/i2c.h   **** 	
  93:./src/i2c.h   **** 	i2c_stop();
  94:./src/i2c.h   **** 	
  95:./src/i2c.h   **** 	return 0;
  96:./src/i2c.h   **** }
  97:./src/i2c.h   **** 
  98:./src/i2c.h   **** uint8_t i2c_receive(uint8_t address, uint8_t* data, uint16_t length)
  99:./src/i2c.h   **** {
 100:./src/i2c.h   **** 	if (i2c_start(address | I2C_READ)) return 1;
 101:./src/i2c.h   **** 	
 102:./src/i2c.h   **** 	for (uint16_t i = 0; i < (length-1); i++)
 103:./src/i2c.h   **** 	{
 104:./src/i2c.h   **** 		data[i] = i2c_read_ack();
 105:./src/i2c.h   **** 	}
 106:./src/i2c.h   **** 	data[(length-1)] = i2c_read_nack();
 107:./src/i2c.h   **** 	
 108:./src/i2c.h   **** 	i2c_stop();
 109:./src/i2c.h   **** 	
 110:./src/i2c.h   **** 	return 0;
 111:./src/i2c.h   **** }
 112:./src/i2c.h   **** 
 113:./src/i2c.h   **** uint8_t i2c_writeReg(uint8_t devaddr, uint8_t regaddr, uint8_t* data, uint16_t length)
 114:./src/i2c.h   **** {
 115:./src/i2c.h   **** 	if (i2c_start(devaddr | 0x00)) return 1;
 116:./src/i2c.h   **** 
 117:./src/i2c.h   **** 	i2c_write(regaddr);
 118:./src/i2c.h   **** 
 119:./src/i2c.h   **** 	for (uint16_t i = 0; i < length; i++)
 120:./src/i2c.h   **** 	{
 121:./src/i2c.h   **** 		if (i2c_write(data[i])) return 1;
 122:./src/i2c.h   **** 	}
 123:./src/i2c.h   **** 
 124:./src/i2c.h   **** 	i2c_stop();
 125:./src/i2c.h   **** 
 126:./src/i2c.h   **** 	return 0;
 127:./src/i2c.h   **** }
 128:./src/i2c.h   **** 
 129:./src/i2c.h   **** uint8_t i2c_readReg(uint8_t devaddr, uint8_t regaddr, uint8_t* data, uint16_t length)
 130:./src/i2c.h   **** {
 131:./src/i2c.h   **** 	if (i2c_start(devaddr)) return 1;
 132:./src/i2c.h   **** 
 133:./src/i2c.h   **** 	i2c_write(regaddr);
 134:./src/i2c.h   **** 
 135:./src/i2c.h   **** 	if (i2c_start(devaddr | 0x01)) return 1;
 136:./src/i2c.h   **** 
 137:./src/i2c.h   **** 	for (uint16_t i = 0; i < (length-1); i++)
 138:./src/i2c.h   **** 	{
 139:./src/i2c.h   **** 		data[i] = i2c_read_ack();
 140:./src/i2c.h   **** 	}
 141:./src/i2c.h   **** 	data[(length-1)] = i2c_read_nack();
 142:./src/i2c.h   **** 
 143:./src/i2c.h   **** 	i2c_stop();
 144:./src/i2c.h   **** 
 145:./src/i2c.h   **** 	return 0;
 146:./src/i2c.h   **** }
 147:./src/i2c.h   **** 
 148:./src/i2c.h   **** void i2c_stop(void)
 149:./src/i2c.h   **** {
 150:./src/i2c.h   **** 	// transmit STOP condition
 151:./src/i2c.h   **** 	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
 386               		.loc 2 151 0
 387 0046 84E9      		ldi r24,lo8(-108)
 388 0048 8093 BC00 		sts 188,r24
 389               	.LVL38:
 390               	.L37:
 391               	.LBE24:
 392               	.LBE23:
  96:./src/i2c.h   **** 
 393               		.loc 2 96 0
 394 004c 812F      		mov r24,r17
 395               	/* epilogue start */
 396 004e 0F90      		pop __tmp_reg__
 397 0050 0F90      		pop __tmp_reg__
 398 0052 DF91      		pop r29
 399 0054 CF91      		pop r28
 400 0056 1F91      		pop r17
 401 0058 FF90      		pop r15
 402 005a EF90      		pop r14
 403 005c DF90      		pop r13
 404 005e CF90      		pop r12
 405 0060 0895      		ret
 406               		.cfi_endproc
 407               	.LFE12:
 409               		.section	.text.i2c_receive,"ax",@progbits
 410               	.global	i2c_receive
 412               	i2c_receive:
 413               	.LFB13:
  99:./src/i2c.h   **** 	if (i2c_start(address | I2C_READ)) return 1;
 414               		.loc 2 99 0
 415               		.cfi_startproc
 416               	.LVL39:
 417 0000 AF92      		push r10
 418               	.LCFI9:
 419               		.cfi_def_cfa_offset 3
 420               		.cfi_offset 10, -2
 421 0002 BF92      		push r11
 422               	.LCFI10:
 423               		.cfi_def_cfa_offset 4
 424               		.cfi_offset 11, -3
 425 0004 CF92      		push r12
 426               	.LCFI11:
 427               		.cfi_def_cfa_offset 5
 428               		.cfi_offset 12, -4
 429 0006 DF92      		push r13
 430               	.LCFI12:
 431               		.cfi_def_cfa_offset 6
 432               		.cfi_offset 13, -5
 433 0008 FF92      		push r15
 434               	.LCFI13:
 435               		.cfi_def_cfa_offset 7
 436               		.cfi_offset 15, -6
 437 000a 0F93      		push r16
 438               	.LCFI14:
 439               		.cfi_def_cfa_offset 8
 440               		.cfi_offset 16, -7
 441 000c 1F93      		push r17
 442               	.LCFI15:
 443               		.cfi_def_cfa_offset 9
 444               		.cfi_offset 17, -8
 445 000e CF93      		push r28
 446               	.LCFI16:
 447               		.cfi_def_cfa_offset 10
 448               		.cfi_offset 28, -9
 449 0010 DF93      		push r29
 450               	.LCFI17:
 451               		.cfi_def_cfa_offset 11
 452               		.cfi_offset 29, -10
 453               	/* prologue: function */
 454               	/* frame size = 0 */
 455               	/* stack size = 9 */
 456               	.L__stack_usage = 9
 457 0012 6B01      		movw r12,r22
 458 0014 8A01      		movw r16,r20
 100:./src/i2c.h   **** 	
 459               		.loc 2 100 0
 460 0016 8160      		ori r24,lo8(1)
 461               	.LVL40:
 462 0018 0E94 0000 		call i2c_start
 463               	.LVL41:
 464 001c F82E      		mov r15,r24
 465 001e 8111      		cpse r24,__zero_reg__
 466 0020 00C0      		rjmp .L44
 467 0022 5601      		movw r10,r12
 468               	.LBB25:
 102:./src/i2c.h   **** 	{
 469               		.loc 2 102 0
 470 0024 E801      		movw r28,r16
 471 0026 2197      		sbiw r28,1
 472               	.L42:
 473               	.LVL42:
 474 0028 C501      		movw r24,r10
 475 002a 8C19      		sub r24,r12
 476 002c 9D09      		sbc r25,r13
 477               	.LVL43:
 102:./src/i2c.h   **** 	{
 478               		.loc 2 102 0 is_stmt 0 discriminator 1
 479 002e 8C17      		cp r24,r28
 480 0030 9D07      		cpc r25,r29
 481 0032 00F4      		brsh .L45
 104:./src/i2c.h   **** 	}
 482               		.loc 2 104 0 is_stmt 1 discriminator 3
 483 0034 0E94 0000 		call i2c_read_ack
 484               	.LVL44:
 485 0038 F501      		movw r30,r10
 486 003a 8193      		st Z+,r24
 487 003c 5F01      		movw r10,r30
 488               	.LVL45:
 489 003e 00C0      		rjmp .L42
 490               	.LVL46:
 491               	.L45:
 492               	.LBE25:
 106:./src/i2c.h   **** 	
 493               		.loc 2 106 0
 494 0040 CC0D      		add r28,r12
 495 0042 DD1D      		adc r29,r13
 496 0044 0E94 0000 		call i2c_read_nack
 497               	.LVL47:
 498 0048 8883      		st Y,r24
 499               	.LBB26:
 500               	.LBB27:
 501               		.loc 2 151 0
 502 004a 84E9      		ldi r24,lo8(-108)
 503 004c 8093 BC00 		sts 188,r24
 504               	.LBE27:
 505               	.LBE26:
 110:./src/i2c.h   **** }
 506               		.loc 2 110 0
 507 0050 00C0      		rjmp .L41
 508               	.LVL48:
 509               	.L44:
 100:./src/i2c.h   **** 	
 510               		.loc 2 100 0
 511 0052 FF24      		clr r15
 512 0054 F394      		inc r15
 513               	.L41:
 111:./src/i2c.h   **** 
 514               		.loc 2 111 0
 515 0056 8F2D      		mov r24,r15
 516               	/* epilogue start */
 517 0058 DF91      		pop r29
 518 005a CF91      		pop r28
 519 005c 1F91      		pop r17
 520 005e 0F91      		pop r16
 521               	.LVL49:
 522 0060 FF90      		pop r15
 523 0062 DF90      		pop r13
 524 0064 CF90      		pop r12
 525               	.LVL50:
 526 0066 BF90      		pop r11
 527 0068 AF90      		pop r10
 528 006a 0895      		ret
 529               		.cfi_endproc
 530               	.LFE13:
 532               		.section	.text.i2c_writeReg,"ax",@progbits
 533               	.global	i2c_writeReg
 535               	i2c_writeReg:
 536               	.LFB14:
 114:./src/i2c.h   **** 	if (i2c_start(devaddr | 0x00)) return 1;
 537               		.loc 2 114 0
 538               		.cfi_startproc
 539               	.LVL51:
 540 0000 AF92      		push r10
 541               	.LCFI18:
 542               		.cfi_def_cfa_offset 3
 543               		.cfi_offset 10, -2
 544 0002 BF92      		push r11
 545               	.LCFI19:
 546               		.cfi_def_cfa_offset 4
 547               		.cfi_offset 11, -3
 548 0004 DF92      		push r13
 549               	.LCFI20:
 550               		.cfi_def_cfa_offset 5
 551               		.cfi_offset 13, -4
 552 0006 EF92      		push r14
 553               	.LCFI21:
 554               		.cfi_def_cfa_offset 6
 555               		.cfi_offset 14, -5
 556 0008 FF92      		push r15
 557               	.LCFI22:
 558               		.cfi_def_cfa_offset 7
 559               		.cfi_offset 15, -6
 560 000a 0F93      		push r16
 561               	.LCFI23:
 562               		.cfi_def_cfa_offset 8
 563               		.cfi_offset 16, -7
 564 000c 1F93      		push r17
 565               	.LCFI24:
 566               		.cfi_def_cfa_offset 9
 567               		.cfi_offset 17, -8
 568 000e CF93      		push r28
 569               	.LCFI25:
 570               		.cfi_def_cfa_offset 10
 571               		.cfi_offset 28, -9
 572 0010 DF93      		push r29
 573               	.LCFI26:
 574               		.cfi_def_cfa_offset 11
 575               		.cfi_offset 29, -10
 576 0012 1F92      		push __zero_reg__
 577               	.LCFI27:
 578               		.cfi_def_cfa_offset 12
 579 0014 CDB7      		in r28,__SP_L__
 580 0016 DEB7      		in r29,__SP_H__
 581               	.LCFI28:
 582               		.cfi_def_cfa_register 28
 583               	/* prologue: function */
 584               	/* frame size = 1 */
 585               	/* stack size = 10 */
 586               	.L__stack_usage = 10
 587 0018 D42E      		mov r13,r20
 588 001a 052F      		mov r16,r21
 589 001c 7901      		movw r14,r18
 115:./src/i2c.h   **** 
 590               		.loc 2 115 0
 591 001e 6983      		std Y+1,r22
 592 0020 0E94 0000 		call i2c_start
 593               	.LVL52:
 594 0024 182F      		mov r17,r24
 595 0026 6981      		ldd r22,Y+1
 596 0028 8823      		tst r24
 597 002a 01F0      		breq .L47
 598               	.LVL53:
 599               	.L50:
 600 002c 11E0      		ldi r17,lo8(1)
 601 002e 00C0      		rjmp .L48
 602               	.LVL54:
 603               	.L47:
 117:./src/i2c.h   **** 
 604               		.loc 2 117 0
 605 0030 862F      		mov r24,r22
 606 0032 0E94 0000 		call i2c_write
 607               	.LVL55:
 608 0036 AD2C      		mov r10,r13
 609 0038 B02E      		mov r11,r16
 610 003a EA0C      		add r14,r10
 611 003c FB1C      		adc r15,r11
 612               	.LVL56:
 613               	.L49:
 614               	.LBB28:
 119:./src/i2c.h   **** 	{
 615               		.loc 2 119 0 discriminator 1
 616 003e AE14      		cp r10,r14
 617 0040 BF04      		cpc r11,r15
 618 0042 01F0      		breq .L52
 121:./src/i2c.h   **** 	}
 619               		.loc 2 121 0
 620 0044 F501      		movw r30,r10
 621 0046 8191      		ld r24,Z+
 622 0048 5F01      		movw r10,r30
 623               	.LVL57:
 624 004a 0E94 0000 		call i2c_write
 625               	.LVL58:
 626 004e 8823      		tst r24
 627 0050 01F0      		breq .L49
 628 0052 00C0      		rjmp .L50
 629               	.LVL59:
 630               	.L52:
 631               	.LBE28:
 632               	.LBB29:
 633               	.LBB30:
 634               		.loc 2 151 0
 635 0054 84E9      		ldi r24,lo8(-108)
 636 0056 8093 BC00 		sts 188,r24
 637               	.LVL60:
 638               	.L48:
 639               	.LBE30:
 640               	.LBE29:
 127:./src/i2c.h   **** 
 641               		.loc 2 127 0
 642 005a 812F      		mov r24,r17
 643               	/* epilogue start */
 644 005c 0F90      		pop __tmp_reg__
 645 005e DF91      		pop r29
 646 0060 CF91      		pop r28
 647 0062 1F91      		pop r17
 648 0064 0F91      		pop r16
 649 0066 FF90      		pop r15
 650 0068 EF90      		pop r14
 651 006a DF90      		pop r13
 652 006c BF90      		pop r11
 653 006e AF90      		pop r10
 654 0070 0895      		ret
 655               		.cfi_endproc
 656               	.LFE14:
 658               		.section	.text.i2c_readReg,"ax",@progbits
 659               	.global	i2c_readReg
 661               	i2c_readReg:
 662               	.LFB15:
 130:./src/i2c.h   **** 	if (i2c_start(devaddr)) return 1;
 663               		.loc 2 130 0
 664               		.cfi_startproc
 665               	.LVL61:
 666 0000 AF92      		push r10
 667               	.LCFI29:
 668               		.cfi_def_cfa_offset 3
 669               		.cfi_offset 10, -2
 670 0002 BF92      		push r11
 671               	.LCFI30:
 672               		.cfi_def_cfa_offset 4
 673               		.cfi_offset 11, -3
 674 0004 CF92      		push r12
 675               	.LCFI31:
 676               		.cfi_def_cfa_offset 5
 677               		.cfi_offset 12, -4
 678 0006 DF92      		push r13
 679               	.LCFI32:
 680               		.cfi_def_cfa_offset 6
 681               		.cfi_offset 13, -5
 682 0008 FF92      		push r15
 683               	.LCFI33:
 684               		.cfi_def_cfa_offset 7
 685               		.cfi_offset 15, -6
 686 000a 0F93      		push r16
 687               	.LCFI34:
 688               		.cfi_def_cfa_offset 8
 689               		.cfi_offset 16, -7
 690 000c 1F93      		push r17
 691               	.LCFI35:
 692               		.cfi_def_cfa_offset 9
 693               		.cfi_offset 17, -8
 694 000e CF93      		push r28
 695               	.LCFI36:
 696               		.cfi_def_cfa_offset 10
 697               		.cfi_offset 28, -9
 698 0010 DF93      		push r29
 699               	.LCFI37:
 700               		.cfi_def_cfa_offset 11
 701               		.cfi_offset 29, -10
 702 0012 1F92      		push __zero_reg__
 703               	.LCFI38:
 704               		.cfi_def_cfa_offset 12
 705 0014 CDB7      		in r28,__SP_L__
 706 0016 DEB7      		in r29,__SP_H__
 707               	.LCFI39:
 708               		.cfi_def_cfa_register 28
 709               	/* prologue: function */
 710               	/* frame size = 1 */
 711               	/* stack size = 10 */
 712               	.L__stack_usage = 10
 713 0018 F82E      		mov r15,r24
 714 001a 6A01      		movw r12,r20
 715 001c 8901      		movw r16,r18
 131:./src/i2c.h   **** 
 716               		.loc 2 131 0
 717 001e 6983      		std Y+1,r22
 718 0020 0E94 0000 		call i2c_start
 719               	.LVL62:
 720 0024 6981      		ldd r22,Y+1
 721 0026 8823      		tst r24
 722 0028 01F0      		breq .L54
 723               	.LVL63:
 724               	.L56:
 725 002a FF24      		clr r15
 726 002c F394      		inc r15
 727 002e 00C0      		rjmp .L55
 728               	.LVL64:
 729               	.L54:
 133:./src/i2c.h   **** 
 730               		.loc 2 133 0
 731 0030 862F      		mov r24,r22
 732 0032 0E94 0000 		call i2c_write
 733               	.LVL65:
 135:./src/i2c.h   **** 
 734               		.loc 2 135 0
 735 0036 8F2D      		mov r24,r15
 736 0038 8160      		ori r24,lo8(1)
 737 003a 0E94 0000 		call i2c_start
 738               	.LVL66:
 739 003e F82E      		mov r15,r24
 740               	.LVL67:
 741 0040 8111      		cpse r24,__zero_reg__
 742 0042 00C0      		rjmp .L56
 743 0044 5601      		movw r10,r12
 744               	.LBB31:
 137:./src/i2c.h   **** 	{
 745               		.loc 2 137 0
 746 0046 0150      		subi r16,1
 747 0048 1109      		sbc r17,__zero_reg__
 748               	.LVL68:
 749               	.L57:
 750 004a C501      		movw r24,r10
 751 004c 8C19      		sub r24,r12
 752 004e 9D09      		sbc r25,r13
 753               	.LVL69:
 137:./src/i2c.h   **** 	{
 754               		.loc 2 137 0 is_stmt 0 discriminator 1
 755 0050 8017      		cp r24,r16
 756 0052 9107      		cpc r25,r17
 757 0054 00F4      		brsh .L59
 139:./src/i2c.h   **** 	}
 758               		.loc 2 139 0 is_stmt 1 discriminator 3
 759 0056 0E94 0000 		call i2c_read_ack
 760               	.LVL70:
 761 005a F501      		movw r30,r10
 762 005c 8193      		st Z+,r24
 763 005e 5F01      		movw r10,r30
 764               	.LVL71:
 765 0060 00C0      		rjmp .L57
 766               	.LVL72:
 767               	.L59:
 768               	.LBE31:
 141:./src/i2c.h   **** 
 769               		.loc 2 141 0
 770 0062 C00E      		add r12,r16
 771 0064 D11E      		adc r13,r17
 772               	.LVL73:
 773 0066 0E94 0000 		call i2c_read_nack
 774               	.LVL74:
 775 006a F601      		movw r30,r12
 776 006c 8083      		st Z,r24
 777               	.LBB32:
 778               	.LBB33:
 779               		.loc 2 151 0
 780 006e 84E9      		ldi r24,lo8(-108)
 781 0070 8093 BC00 		sts 188,r24
 782               	.LVL75:
 783               	.L55:
 784               	.LBE33:
 785               	.LBE32:
 146:./src/i2c.h   **** 
 786               		.loc 2 146 0
 787 0074 8F2D      		mov r24,r15
 788               	/* epilogue start */
 789 0076 0F90      		pop __tmp_reg__
 790 0078 DF91      		pop r29
 791 007a CF91      		pop r28
 792 007c 1F91      		pop r17
 793 007e 0F91      		pop r16
 794 0080 FF90      		pop r15
 795 0082 DF90      		pop r13
 796 0084 CF90      		pop r12
 797 0086 BF90      		pop r11
 798 0088 AF90      		pop r10
 799 008a 0895      		ret
 800               		.cfi_endproc
 801               	.LFE15:
 803               		.section	.text.i2c_stop,"ax",@progbits
 804               	.global	i2c_stop
 806               	i2c_stop:
 807               	.LFB16:
 149:./src/i2c.h   **** 	// transmit STOP condition
 808               		.loc 2 149 0
 809               		.cfi_startproc
 810               	/* prologue: function */
 811               	/* frame size = 0 */
 812               	/* stack size = 0 */
 813               	.L__stack_usage = 0
 814               		.loc 2 151 0
 815 0000 84E9      		ldi r24,lo8(-108)
 816 0002 8093 BC00 		sts 188,r24
 817 0006 0895      		ret
 818               		.cfi_endproc
 819               	.LFE16:
 821               		.section	.text.init_io,"ax",@progbits
 822               	.global	init_io
 824               	init_io:
 825               	.LFB17:
 826               		.file 3 "src/main.c"
   1:src/main.c    **** /*
   2:src/main.c    ****  * (c) Anil Kumar Pugalia, 2010. Email: email@sarika-pugs.com
   3:src/main.c    ****  *
   4:src/main.c    ****  * ATmega48/88/168, ATmega16/32
   5:src/main.c    ****  * 
   6:src/main.c    ****  * Example Blink. Toggles all IO pins at 1Hz
   7:src/main.c    ****  */
   8:src/main.c    **** 
   9:src/main.c    **** #include <avr/io.h>
  10:src/main.c    **** #include <util/delay.h>
  11:src/main.c    **** #include <stdbool.h>
  12:src/main.c    **** #include <src/pins.h>
  13:src/main.c    **** //#include <src/max5805.h>
  14:src/main.c    **** #include <src/i2c.h>
  15:src/main.c    **** 
  16:src/main.c    **** void init_io(void)
  17:src/main.c    **** {
 827               		.loc 3 17 0
 828               		.cfi_startproc
 829               	/* prologue: function */
 830               	/* frame size = 0 */
 831               	/* stack size = 0 */
 832               	.L__stack_usage = 0
  18:src/main.c    ****     DDRB = 0xff;
 833               		.loc 3 18 0
 834 0000 8FEF      		ldi r24,lo8(-1)
 835 0002 84B9      		out 0x4,r24
  19:src/main.c    ****     PORTB = 0x00;
 836               		.loc 3 19 0
 837 0004 15B8      		out 0x5,__zero_reg__
 838 0006 0895      		ret
 839               		.cfi_endproc
 840               	.LFE17:
 842               		.section	.text.startup.main,"ax",@progbits
 843               	.global	main
 845               	main:
 846               	.LFB18:
  20:src/main.c    **** }
  21:src/main.c    **** 
  22:src/main.c    **** int main(void)
  23:src/main.c    **** {
 847               		.loc 3 23 0
 848               		.cfi_startproc
 849               	/* prologue: function */
 850               	/* frame size = 0 */
 851               	/* stack size = 0 */
 852               	.L__stack_usage = 0
  24:src/main.c    **** 	init_io();
 853               		.loc 3 24 0
 854 0000 0E94 0000 		call init_io
 855               	.LVL76:
 856               	.L63:
 857               	.LBB42:
 858               	.LBB43:
  15:./src/pins.h  ****       break;
 859               		.loc 1 15 0 discriminator 1
 860 0004 289A      		sbi 0x5,0
 861               	.LVL77:
 862               	.LBE43:
 863               	.LBE42:
 864               	.LBB44:
 865               	.LBB45:
 866               		.file 4 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 867               		.loc 4 163 0 discriminator 1
 868 0006 2FEF      		ldi r18,lo8(1599999)
 869 0008 89E6      		ldi r24,hi8(1599999)
 870 000a 98E1      		ldi r25,hlo8(1599999)
 871 000c 2150      	1:	subi r18,1
 872 000e 8040      		sbci r24,0
 873 0010 9040      		sbci r25,0
 874 0012 01F4      		brne 1b
 875 0014 00C0      		rjmp .
 876 0016 0000      		nop
 877               	.LVL78:
 878               	.LBE45:
 879               	.LBE44:
 880               	.LBB46:
 881               	.LBB47:
  15:./src/pins.h  ****       break;
 882               		.loc 1 15 0 discriminator 1
 883 0018 2898      		cbi 0x5,0
 884               	.LVL79:
 885               	.LBE47:
 886               	.LBE46:
 887               	.LBB48:
 888               	.LBB49:
 889               		.loc 4 163 0 discriminator 1
 890 001a 2FEF      		ldi r18,lo8(1599999)
 891 001c 89E6      		ldi r24,hi8(1599999)
 892 001e 98E1      		ldi r25,hlo8(1599999)
 893 0020 2150      	1:	subi r18,1
 894 0022 8040      		sbci r24,0
 895 0024 9040      		sbci r25,0
 896 0026 01F4      		brne 1b
 897 0028 00C0      		rjmp .
 898 002a 0000      		nop
 899 002c 00C0      		rjmp .L63
 900               	.LBE49:
 901               	.LBE48:
 902               		.cfi_endproc
 903               	.LFE18:
 905               		.text
 906               	.Letext0:
 907               		.file 5 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccqFAo5E.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccqFAo5E.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccqFAo5E.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccqFAo5E.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccqFAo5E.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccqFAo5E.s:13     .text.portwrite:0000000000000000 portwrite
     /tmp/ccqFAo5E.s:127    .text.i2c_init:0000000000000000 i2c_init
     /tmp/ccqFAo5E.s:146    .text.i2c_start:0000000000000000 i2c_start
     /tmp/ccqFAo5E.s:213    .text.i2c_write:0000000000000000 i2c_write
     /tmp/ccqFAo5E.s:250    .text.i2c_read_ack:0000000000000000 i2c_read_ack
     /tmp/ccqFAo5E.s:276    .text.i2c_read_nack:0000000000000000 i2c_read_nack
     /tmp/ccqFAo5E.s:302    .text.i2c_transmit:0000000000000000 i2c_transmit
     /tmp/ccqFAo5E.s:412    .text.i2c_receive:0000000000000000 i2c_receive
     /tmp/ccqFAo5E.s:535    .text.i2c_writeReg:0000000000000000 i2c_writeReg
     /tmp/ccqFAo5E.s:661    .text.i2c_readReg:0000000000000000 i2c_readReg
     /tmp/ccqFAo5E.s:806    .text.i2c_stop:0000000000000000 i2c_stop
     /tmp/ccqFAo5E.s:824    .text.init_io:0000000000000000 init_io
     /tmp/ccqFAo5E.s:845    .text.startup.main:0000000000000000 main

NO UNDEFINED SYMBOLS
